{% extends 'dashboard/base.html' %}

{% block title %}Reports | DisgrasEye{% endblock %}

{% block extra_scripts %}
<script>
let charts = {};
let reportData = {};

// Get Supabase client from global scope
function getSupabaseClient() {
    if (window._supabase) {
        return window._supabase;
    } else if (typeof getSupabaseClient === 'function') {
        return getSupabaseClient();
    }
    
    // Fallback: use Django context variables
    const supabaseUrl = "{{ SUPABASE_URL|default:'https://ivigoibymrcvaftgayqv.supabase.co' }}";
    const supabaseAnonKey = "{{ SUPABASE_ANON_KEY|default:'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml2aWdvaWJ5bXJjdmFmdGdheXF2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM5MDI2MDgsImV4cCI6MjA3OTQ3ODYwOH0.c3MoFVyNGXwZ3zqtgWz62Du0WfA7pranyAXDwRpy5sw' }}";
    
    return supabase.createClient(supabaseUrl, supabaseAnonKey);
}

document.addEventListener('DOMContentLoaded', function() {
    loadReportData();
});

async function loadReportData() {
    try {
        const supabase = getSupabaseClient();
        if (!supabase) {
            console.error('Supabase client not available');
            initializeChartsWithDemoData();
            return;
        }

        // Load accident data
        const { data: accidentData, error: accidentError } = await supabase
            .from('accident_detections')
            .select('*')
            .order('detection_time', { ascending: false });

        if (accidentError) {
            console.error('Error loading accident data:', accidentError);
            initializeChartsWithDemoData();
            return;
        }

        // Load alerts data
        const { data: alertData, error: alertError } = await supabase
            .from('alerts')
            .select('*');

        if (alertError) {
            console.error('Error loading alert data:', alertError);
        }

        // Process data for charts
        processReportData(accidentData || [], alertData || []);
        initializeCharts();
        updateQuickStats(accidentData || [], alertData || []);

    } catch (error) {
        console.error('Error loading report data:', error);
        initializeChartsWithDemoData();
    }
}

function processReportData(accidentDetections, alerts) {
    // Calculate monthly data
    const monthlyCounts = Array(12).fill(0);
    const crashTypeCounts = {
        'Rear-end': 0,
        'Side-impact': 0, 
        'Head-on': 0,
        'Rollover': 0,
        'Other': 0
    };
    
    accidentDetections.forEach(detection => {
        try {
            const date = new Date(detection.detection_time);
            const month = date.getMonth();
            monthlyCounts[month]++;
            
            // Simple crash type detection based on description/confidence
            if (detection.description) {
                const desc = detection.description.toLowerCase();
                if (desc.includes('rear') || desc.includes('back')) {
                    crashTypeCounts['Rear-end']++;
                } else if (desc.includes('side') || desc.includes('lateral')) {
                    crashTypeCounts['Side-impact']++;
                } else if (desc.includes('head') || desc.includes('front')) {
                    crashTypeCounts['Head-on']++;
                } else if (desc.includes('roll') || desc.includes('overturn')) {
                    crashTypeCounts['Rollover']++;
                } else {
                    crashTypeCounts['Other']++;
                }
            }
        } catch (e) {
            console.error('Error processing detection:', e);
        }
    });

    // Calculate response times from alerts
    const responseTimes = {};
    alerts.forEach(alert => {
        if (alert.response_time && alert.alert_time) {
            try {
                const alertTime = new Date(alert.alert_time);
                const responseTime = new Date(alert.response_time);
                const day = alertTime.toLocaleDateString('en-US', { weekday: 'short' });
                const minutes = (responseTime - alertTime) / (1000 * 60);
                
                if (!responseTimes[day]) {
                    responseTimes[day] = { total: 0, count: 0 };
                }
                responseTimes[day].total += minutes;
                responseTimes[day].count++;
            } catch (e) {
                console.error('Error processing response time:', e);
            }
        }
    });

    // Calculate camera performance
    const cameraStats = {};
    accidentDetections.forEach(detection => {
        const cameraId = detection.camera_id || 'unknown';
        if (!cameraStats[cameraId]) {
            cameraStats[cameraId] = { detections: 0, totalConfidence: 0 };
        }
        cameraStats[cameraId].detections++;
        cameraStats[cameraId].totalConfidence += (detection.confidence || 50);
    });

    reportData = {
        monthlyData: monthlyCounts,
        crashTypeData: Object.values(crashTypeCounts),
        responseTimeData: calculateAvgResponseTimes(responseTimes),
        cameraPerformance: calculateCameraPerformance(cameraStats),
        totalIncidents: accidentDetections.length,
        pendingAlerts: alerts.filter(a => a.response_status === 'Unacknowledged').length,
        detectionAccuracy: calculateDetectionAccuracy(accidentDetections),
        avgResponseTime: calculateOverallAvgResponseTime(alerts)
    };
}

function calculateAvgResponseTimes(responseTimes) {
    const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    return days.map(day => {
        if (responseTimes[day] && responseTimes[day].count > 0) {
            return parseFloat((responseTimes[day].total / responseTimes[day].count).toFixed(1));
        }
        return Math.random() * 1.5 + 1.5; // Demo data if no real data
    });
}

function calculateCameraPerformance(cameraStats) {
    // Calculate average performance metrics
    const totalCameras = Object.keys(cameraStats).length;
    if (totalCameras === 0) return [85, 92, 78, 88, 82]; // Demo data
    
    let detectionRate = 0;
    let avgConfidence = 0;
    
    Object.values(cameraStats).forEach(stats => {
        detectionRate += stats.detections;
        avgConfidence += stats.totalConfidence / stats.detections;
    });
    
    detectionRate = (detectionRate / totalCameras) * 10; // Normalize
    avgConfidence = avgConfidence / totalCameras;
    
    return [
        Math.min(95, detectionRate), // Detection Rate
        92, // Uptime (demo)
        Math.min(90, avgConfidence), // Image Quality
        88, // Network Stability (demo)
        Math.min(90, detectionRate * 0.9) // Alert Accuracy
    ];
}

function calculateDetectionAccuracy(detections) {
    if (detections.length === 0) return 0;
    const verified = detections.filter(d => d.status === 'Verified').length;
    return Math.round((verified / detections.length) * 100);
}

function calculateOverallAvgResponseTime(alerts) {
    const validAlerts = alerts.filter(a => a.response_time && a.alert_time);
    if (validAlerts.length === 0) return '2.1';
    
    let totalMinutes = 0;
    validAlerts.forEach(alert => {
        try {
            const alertTime = new Date(alert.alert_time);
            const responseTime = new Date(alert.response_time);
            totalMinutes += (responseTime - alertTime) / (1000 * 60);
        } catch (e) {
            console.error('Error calculating response time:', e);
        }
    });
    
    return (totalMinutes / validAlerts.length).toFixed(1);
}

function updateQuickStats(detections, alerts) {
    // Update quick stats in the UI
    document.querySelectorAll('.quick-stat').forEach(stat => {
        const type = stat.dataset.type;
        switch(type) {
            case 'total-incidents':
                stat.textContent = detections.length;
                break;
            case 'avg-response':
                stat.textContent = reportData.avgResponseTime + 'min';
                break;
            case 'detection-accuracy':
                stat.textContent = reportData.detectionAccuracy + '%';
                break;
            case 'pending-alerts':
                const pending = alerts.filter(a => a.response_status === 'Unacknowledged').length;
                stat.textContent = pending;
                break;
        }
    });
}

function initializeCharts() {
    // Monthly Crash Trends Chart
    const monthlyCtx = document.getElementById('monthlyCrashChart');
    if (monthlyCtx && reportData.monthlyData) {
        charts.monthlyCrashChart = new Chart(monthlyCtx, {
            type: 'line',
            data: {
                labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                datasets: [{
                    label: 'Crashes Detected',
                    data: reportData.monthlyData,
                    borderColor: '#38BDF8',
                    backgroundColor: 'rgba(56, 189, 248, 0.1)',
                    tension: 0.4,
                    fill: true
                }]
            },
            options: getChartOptions()
        });
    }

    // Crash Type Distribution Chart
    const crashTypeCtx = document.getElementById('crashTypeChart');
    if (crashTypeCtx && reportData.crashTypeData) {
        charts.crashTypeChart = new Chart(crashTypeCtx, {
            type: 'doughnut',
            data: {
                labels: ['Rear-end', 'Side-impact', 'Head-on', 'Rollover', 'Other'],
                datasets: [{
                    data: reportData.crashTypeData,
                    backgroundColor: [
                        '#EF4444',
                        '#F59E0B',
                        '#10B981',
                        '#3B82F6',
                        '#8B5CF6'
                    ]
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom',
                        labels: { color: '#CBD5E1' }
                    }
                }
            }
        });
    }

    // Response Time Analysis Chart
    const responseTimeCtx = document.getElementById('responseTimeChart');
    if (responseTimeCtx && reportData.responseTimeData) {
        charts.responseTimeChart = new Chart(responseTimeCtx, {
            type: 'bar',
            data: {
                labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
                datasets: [{
                    label: 'Avg Response Time (min)',
                    data: reportData.responseTimeData,
                    backgroundColor: '#10B981'
                }]
            },
            options: getChartOptions()
        });
    }

    // Camera Performance Chart
    const cameraPerformanceCtx = document.getElementById('cameraPerformanceChart');
    if (cameraPerformanceCtx && reportData.cameraPerformance) {
        charts.cameraPerformanceChart = new Chart(cameraPerformanceCtx, {
            type: 'radar',
            data: {
                labels: ['Detection Rate', 'Uptime', 'Image Quality', 'Network Stability', 'Alert Accuracy'],
                datasets: [{
                    label: 'Camera Performance',
                    data: reportData.cameraPerformance,
                    backgroundColor: 'rgba(56, 189, 248, 0.2)',
                    borderColor: '#38BDF8',
                    pointBackgroundColor: '#38BDF8'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    r: {
                        angleLines: { color: 'rgba(203, 213, 225, 0.1)' },
                        grid: { color: 'rgba(203, 213, 225, 0.1)' },
                        pointLabels: { color: '#CBD5E1' },
                        ticks: { 
                            color: '#CBD5E1',
                            backdropColor: 'transparent'
                        }
                    }
                },
                plugins: {
                    legend: {
                        labels: { color: '#CBD5E1' }
                    }
                }
            }
        });
    }
}

function getChartOptions() {
    return {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {
                labels: { color: '#CBD5E1' }
            }
        },
        scales: {
            y: {
                beginAtZero: true,
                grid: { color: 'rgba(203, 213, 225, 0.1)' },
                ticks: { color: '#CBD5E1' }
            },
            x: {
                grid: { color: 'rgba(203, 213, 225, 0.1)' },
                ticks: { color: '#CBD5E1' }
            }
        }
    };
}

function initializeChartsWithDemoData() {
    reportData = {
        monthlyData: [12, 19, 15, 25, 22, 30, 28, 26, 24, 20, 18, 22],
        crashTypeData: [45, 25, 15, 10, 5],
        responseTimeData: [2.3, 1.8, 2.5, 1.9, 2.1, 2.8, 2.4],
        cameraPerformance: [85, 92, 78, 88, 82],
        totalIncidents: 156,
        pendingAlerts: 12,
        detectionAccuracy: 94,
        avgResponseTime: '2.1'
    };
    
    initializeCharts();
    updateQuickStats([], []);
}

async function exportReport(type) {
    try {
        const supabase = getSupabaseClient();
        if (!supabase) {
            alert('Cannot generate report: Database connection unavailable');
            return;
        }

        let startDate, endDate;
        const now = new Date();
        
        switch(type) {
            case 'daily':
                startDate = new Date(now.setHours(0, 0, 0, 0));
                endDate = new Date(now.setHours(23, 59, 59, 999));
                break;
            case 'weekly':
                startDate = new Date(now.setDate(now.getDate() - 7));
                endDate = new Date();
                break;
            default:
                startDate = new Date(now.setMonth(now.getMonth() - 1));
                endDate = new Date();
        }

        // Fetch data for the report
        const { data: reportData, error } = await supabase
            .from('accident_detections')
            .select('*')
            .gte('detection_time', startDate.toISOString())
            .lte('detection_time', endDate.toISOString());

        if (error) {
            throw error;
        }

        // Generate PDF content
        const reportContent = generateReportContent(type, reportData, startDate, endDate);
        
        // Create and download PDF
        downloadPDF(reportContent, `DisgrasEye_${type}_report_${new Date().toISOString().split('T')[0]}.pdf`);
        
        alert(`${type.charAt(0).toUpperCase() + type.slice(1)} report generated successfully!`);

    } catch (error) {
        console.error('Error generating report:', error);
        alert(`Error generating ${type} report: ${error.message}`);
    }
}

function generateReportContent(type, data, startDate, endDate) {
    // This would be replaced with actual PDF generation logic
    // For now, we'll just create a simple text representation
    return `
        DisgrasEye Crash Detection Report
        ==================================
        Report Type: ${type.toUpperCase()}
        Period: ${startDate.toLocaleDateString()} - ${endDate.toLocaleDateString()}
        
        Summary:
        - Total Incidents: ${data.length}
        - Detection Period: ${startDate.toLocaleDateString()} to ${endDate.toLocaleDateString()}
        - Generated: ${new Date().toLocaleString()}
        
        Incident Details:
        ${data.map((incident, i) => `
        ${i+1}. ${new Date(incident.detection_time).toLocaleString()}
           Camera: ${incident.camera_id || 'Unknown'}
           Status: ${incident.status || 'Unknown'}
           Confidence: ${incident.confidence || 'N/A'}%
        `).join('\n')}
    `;
}

function downloadPDF(content, filename) {
    // Simple text file download for demo
    const blob = new Blob([content], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
}

function generateCustomReport() {
    // Open modal for custom report configuration
    const modalHTML = `
        <div class="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
            <div class="bg-[#1E293B] rounded-lg p-6 w-full max-w-md border border-gray-600">
                <h3 class="text-xl font-bold mb-4 text-sky">Custom Report Configuration</h3>
                
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm text-gray-400 mb-1">Start Date</label>
                        <input type="date" id="startDate" class="w-full bg-darkbg border border-gray-600 rounded p-2 text-white">
                    </div>
                    
                    <div>
                        <label class="block text-sm text-gray-400 mb-1">End Date</label>
                        <input type="date" id="endDate" class="w-full bg-darkbg border border-gray-600 rounded p-2 text-white">
                    </div>
                    
                    <div>
                        <label class="block text-sm text-gray-400 mb-1">Report Type</label>
                        <select id="reportType" class="w-full bg-darkbg border border-gray-600 rounded p-2 text-white">
                            <option value="detailed">Detailed Report</option>
                            <option value="summary">Summary Report</option>
                            <option value="performance">Performance Analysis</option>
                        </select>
                    </div>
                </div>
                
                <div class="flex gap-3 mt-6">
                    <button onclick="generateCustomReportFromModal()" class="flex-1 bg-greenlight hover:bg-greenlight/80 text-white py-2 rounded transition">
                        Generate
                    </button>
                    <button onclick="closeCustomReportModal()" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white py-2 rounded transition">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    `;
    
    const modal = document.createElement('div');
    modal.innerHTML = modalHTML;
    document.body.appendChild(modal);
    
    // Set default dates
    const today = new Date();
    const lastMonth = new Date(today.setMonth(today.getMonth() - 1));
    
    modal.querySelector('#startDate').value = lastMonth.toISOString().split('T')[0];
    modal.querySelector('#endDate').value = new Date().toISOString().split('T')[0];
}

// These need to be global for the modal buttons
window.generateCustomReportFromModal = async function() {
    const modal = document.querySelector('.fixed.inset-0');
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;
    const reportType = document.getElementById('reportType').value;
    
    if (!startDate || !endDate) {
        alert('Please select both start and end dates');
        return;
    }
    
    try {
        const supabase = getSupabaseClient();
        if (!supabase) {
            alert('Database connection unavailable');
            return;
        }
        
        const { data, error } = await supabase
            .from('accident_detections')
            .select('*')
            .gte('detection_time', `${startDate}T00:00:00`)
            .lte('detection_time', `${endDate}T23:59:59`);
        
        if (error) throw error;
        
        const reportContent = `
            Custom Report - ${reportType}
            ==============================
            Period: ${startDate} to ${endDate}
            Report Type: ${reportType}
            Total Incidents: ${data.length}
            
            ${data.map((incident, i) => `
            ${i+1}. ${new Date(incident.detection_time).toLocaleString()}
               Camera: ${incident.camera_id || 'Unknown'}
               Status: ${incident.status || 'Unknown'}
               Confidence: ${incident.confidence || 'N/A'}%
               ${incident.description ? `Description: ${incident.description}` : ''}
            `).join('\n')}
        `;
        
        downloadPDF(reportContent, `Custom_Report_${startDate}_to_${endDate}.txt`);
        closeCustomReportModal();
        
    } catch (error) {
        console.error('Error generating custom report:', error);
        alert('Error generating custom report: ' + error.message);
    }
};

window.closeCustomReportModal = function() {
    const modal = document.querySelector('.fixed.inset-0');
    if (modal) {
        modal.remove();
    }
};
</script>
{% endblock %}

{% block content %}
<div class="mb-6">
    <h2 class="text-2xl font-bold flex items-center gap-2">
        <i class="bi bi-graph-up text-sky"></i> Analytics & Reports
    </h2>
    <p class="text-gray-400 mt-2">Comprehensive crash detection statistics and performance metrics</p>
</div>

<!-- Quick Stats -->
<div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
    <div class="bg-[#1E293B] p-4 rounded-lg border border-gray-600 text-center">
        <i class="bi bi-car-front text-sky text-2xl mb-2"></i>
        <h3 class="text-lg font-bold text-sky quick-stat" data-type="total-incidents">0</h3>
        <p class="text-gray-400 text-sm">Total Incidents</p>
    </div>
    <div class="bg-[#1E293B] p-4 rounded-lg border border-gray-600 text-center">
        <i class="bi bi-clock text-greenlight text-2xl mb-2"></i>
        <h3 class="text-lg font-bold text-greenlight quick-stat" data-type="avg-response">0min</h3>
        <p class="text-gray-400 text-sm">Avg Response Time</p>
    </div>
    <div class="bg-[#1E293B] p-4 rounded-lg border border-gray-600 text-center">
        <i class="bi bi-check-circle text-gold text-2xl mb-2"></i>
        <h3 class="text-lg font-bold text-gold quick-stat" data-type="detection-accuracy">0%</h3>
        <p class="text-gray-400 text-sm">Detection Accuracy</p>
    </div>
    <div class="bg-[#1E293B] p-4 rounded-lg border border-gray-600 text-center">
        <i class="bi bi-exclamation-triangle text-alert text-2xl mb-2"></i>
        <h3 class="text-lg font-bold text-alert quick-stat" data-type="pending-alerts">0</h3>
        <p class="text-gray-400 text-sm">Pending Alerts</p>
    </div>
</div>

<!-- Crash Statistics Overview -->
<div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
    <!-- Monthly Crash Trends -->
    <div class="bg-[#1E293B] rounded-xl p-6 border border-gray-600">
        <div class="flex justify-between items-center mb-4">
            <h3 class="text-xl font-bold flex items-center gap-2">
                <i class="bi bi-graph-up-arrow text-sky"></i> Monthly Crash Trends
            </h3>
            <button onclick="loadReportData()" class="text-sm bg-sky/20 hover:bg-sky/30 text-sky px-3 py-1 rounded flex items-center gap-1 transition">
                <i class="bi bi-arrow-clockwise"></i> Refresh
            </button>
        </div>
        <div class="h-64">
            <canvas id="monthlyCrashChart"></canvas>
        </div>
    </div>

    <!-- Crash Type Distribution -->
    <div class="bg-[#1E293B] rounded-xl p-6 border border-gray-600">
        <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
            <i class="bi bi-pie-chart text-alert"></i> Crash Type Distribution
        </h3>
        <div class="h-64">
            <canvas id="crashTypeChart"></canvas>
        </div>
    </div>
</div>

<!-- Detailed Statistics -->
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-2 gap-6 mb-8">
    <!-- Response Time Analysis -->
    <div class="bg-[#1E293B] rounded-xl p-6 border border-gray-600">
        <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
            <i class="bi bi-speedometer2 text-greenlight"></i> Response Time Analysis
        </h3>
        <div class="h-64">
            <canvas id="responseTimeChart"></canvas>
        </div>
    </div>

    <!-- Camera Performance -->
    <div class="bg-[#1E293B] rounded-xl p-6 border border-gray-600">
        <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
            <i class="bi bi-camera-video text-gold"></i> Camera Performance
        </h3>
        <div class="h-64">
            <canvas id="cameraPerformanceChart"></canvas>
        </div>
    </div>
</div>

<!-- Report Generation -->
<div class="bg-[#1E293B] rounded-xl p-6 border border-gray-600">
    <h3 class="text-xl font-bold mb-4 flex items-center gap-2">
        <i class="bi bi-file-earmark-arrow-down text-sky"></i> Generate Reports
    </h3>
    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div class="bg-darkbg p-4 rounded-lg border border-gray-600">
            <h4 class="font-semibold mb-2 text-sky">Daily Report</h4>
            <p class="text-sm text-gray-400 mb-3">Generate today's crash detection summary</p>
            <button onclick="exportReport('daily')" class="w-full bg-sky hover:bg-sky/80 text-white py-2 rounded transition flex items-center justify-center gap-2">
                <i class="bi bi-download"></i> Download PDF
            </button>
        </div>
        <div class="bg-darkbg p-4 rounded-lg border border-gray-600">
            <h4 class="font-semibold mb-2 text-alert">Weekly Report</h4>
            <p class="text-sm text-gray-400 mb-3">Weekly performance and incident analysis</p>
            <button onclick="exportReport('weekly')" class="w-full bg-alert hover:bg-alert/80 text-white py-2 rounded transition flex items-center justify-center gap-2">
                <i class="bi bi-download"></i> Download PDF
            </button>
        </div>
        <div class="bg-darkbg p-4 rounded-lg border border-gray-600">
            <h4 class="font-semibold mb-2 text-greenlight">Custom Report</h4>
            <p class="text-sm text-gray-400 mb-3">Custom date range and metrics</p>
            <button onclick="generateCustomReport()" class="w-full bg-greenlight hover:bg-greenlight/80 text-white py-2 rounded transition flex items-center justify-center gap-2">
                <i class="bi bi-gear"></i> Configure
            </button>
        </div>
    </div>
</div>
{% endblock %}